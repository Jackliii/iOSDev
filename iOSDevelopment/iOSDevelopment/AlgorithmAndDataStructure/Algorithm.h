//
//  Algorithm.h
//  AlgorithmAndDataStructure
//
//  Created by 大明 on 2021/8/27.
//

#import <Foundation/Foundation.h>
#import "Node.h"

NS_ASSUME_NONNULL_BEGIN

@interface Algorithm : NSObject

/**
 快速排序
 */
+ (void)quickSort:(NSArray *)arr;

/**
 二分查找
 */
+ (NSInteger)binarySearch:(NSArray *)arr target:(NSInteger)target;

/**
 题目1：输入2个int型整数，它们进行除法计算并返回商，要求不得使用乘号'*'、除号'/'及求余符号'%'。当发生溢出时，返回最大的整数值。假设除数不为0。例如，输入15和2，输出15/2的结果，即7。
*/
+ (int)division:(int)v1 v2:(int)v2;

/**
 题目2：输入两个表示二进制的字符串，请计算它们的和，并以二进制字符串的形式输出。例如，输入的二进制字符串分别是"11"和"10"，则输出"101"。
 */
+ (NSString *)addBinary:(NSString *)str1 str2:(NSString *)str2;

/**
 题目3：输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0，1，1，2，1]。
 */
+ (NSArray *)countBits:(NSInteger)num;

/**
 题目4：输入一个整数数组，数组中只有一个数字出现了一次，而其他数字都出现了3次。请找出那个只出现一次的数字。例如，如果输入的数组为[0，1，0，1，0，1，100]，则只出现一次的数字是100。
*/
+ (NSInteger)singleNumber:(NSArray *)nums;

/**
 题目5：输入一个递增排序的数组和一个值k，请问如何在数组中找出两个和为k的数字并返回它们的下标？假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。例如，输入数组[1，2，4，6，10]，k的值为8，数组中的数字2与6的和为8，它们的下标分别为1与3。
 */
+ (NSArray *)twoSum:(NSArray *)arr add:(NSInteger)target;

/**
 题目6：输入一个数组，如何找出数组中所有和为0的3个数字的三元组？需要注意的是，返回值中不得包含重复的三元组。例如，在数组[-1，0，1，2，-1，-4]中有两个三元组的和为0，它们分别是[-1，0，1]和[-1，-1，2]。
 */
+ (NSArray *)threeSum:(NSArray *)arr;

/**
 题目7：输入一个正整数组成的数组和一个正整数k，请问数组中和大于或等于k的连续子数组的最短长度是多少？如果不存在所有数字之和大于或等于k的子数组，则返回0。例如，输入数组[5，1，4，3]，k的值为7，和大于或等于7的最短连续子数组是[4，3]，因此输出它的长度2。
 */
+ (int)minSubArray:(NSArray *)arr k:(NSInteger)k;

/**
 题目8：输入一个由正整数组成的数组和一个正整数k，请问数组中有多少个数字乘积小于k的连续子数组？例如，输入数组[10，5，2，6]，k的值为100，有8个子数组的所有数字的乘积小于100，它们分别是[10]、[5]、[2]、[6]、[10，5]、[5，2]、[2，6]和[5，2，6]。
 */
+ (int)numSubArrayProductLessThanK:(NSArray *)arr k:(NSInteger)k;

/**
 题目9：输入一个整数数组和一个整数k，请问数组中有多少个数字之和等于k的连续子数组？例如，输入数组[1，1，1]，k的值为2，有2个连续子数组之和等于2。
 */
+ (int)subArraySum:(NSArray *)arr k:(int)k;

/**
 题目10：输入一个只包含0和1的数组，请问如何求0和1的个数相同的最长连续子数组的长度？例如，在数组[0，1，0]中有两个子数组包含相同个数的0和1，分别是[0，1]和[1，0]，它们的长度都是2，因此输出2。
 */
+ (int)findMaxLength:(NSArray *)arr;
    
/**
 题目11：输入一个整数数组，如果一个数字左边的子数组的数字之和等于右边的子数组的数字之和，那么返回该数字的下标。如果存在多个这样的数字，则返回最左边一个数字的下标。如果不存在这样的数字，则返回-1。例如，在数组[1，7，3，6，2，9]中，下标为3的数字（值为6）的左边3个数字1、7、3的和与右边两个数字2和9的和相等，都是11，因此正确的输出值是3。
 */
+ (int)pivotIndex:(NSArray *)arr;

/**
 题目12：输入字符串s1和s2，如何判断字符串s2中是否包含字符串s1的某个变位词？如果字符串s2中包含字符串s1的某个变位词，则字符串s1至少有一个变位词是字符串s2的子字符串。假设两个字符串中只包含英文小写字母。例如，字符串s1为"ac"，字符串s2为"dgcaf"，由于字符串s2中包含字符串s1的变位词"ca"，因此输出为true。如果字符串s1为"ab"，字符串s2为"dgcaf"，则输出为false。
 */
+ (BOOL)checkInclusion:(NSString *)str1 str2:(NSString *)str2;

/**
 题目13：输入字符串s1和s2，如何找出字符串s1的所有变位词在字符串s2中的起始下标？假设两个字符串中只包含英文小写字母。例如，字符串s2为"cbadabacg"，字符串s1为"abc"，字符串s1的两个变位词"cba"和"bac"是字符串s2中的子字符串，输出它们在字符串s2中的起始下标0和5。
 */
+ (NSArray *)findAnagrams:(NSString *)str1 str2:(NSString *)str2;
   
/**
 题目14：输入一个字符串，求该字符串中不含重复字符的最长子字符串的长度。例如，输入字符串"babcca"，其最长的不含重复字符的子字符串是"abc"，长度为3。
 */
+ (int)lengthOfLongestSubstring:(NSString *)str;

/**
 题目15：给定一个字符串，请判断它是不是回文。假设只需要考虑字母和数字字符，并忽略大小写。例如，"Was it a cat I saw？"是一个回文字符串，而"race a car"不是回文字符串。
 */
+ (BOOL)isPalindrome:(NSString *)str;

/**
 题目16：给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串。例如，如果输入字符串"abca"，由于删除字符'b'或'c'就能得到一个回文字符串，因此输出为true。
 */
+ (BOOL)vaildPalindrome:(NSString *)str;

/**
 题目17：给定一个字符串，请问该字符串中有多少个回文连续子字符串？例如，字符串"abc"有3个回文子字符串，分别为"a"、"b"和"c"；而字符串"aaa"有6个回文子字符串，分别为"a"、"a"、"a"、"aa"、"aa"和"aaa"。
 */
+ (int)subPalindromeStringCount:(NSString *)str;

/**
 题目18：如果给定一个链表，请问如何删除链表中的倒数第k个节点？假设链表中节点的总数为n，那么1≤k≤n。要求只能遍历链表一次。
 */
+ (LinkedNode *)removeNthFromeEnd:(LinkedNode *)head n:(int)n;

/**
 题目19：如果一个链表中包含环，那么应该如何找出环的入口节点？从链表的头节点开始顺着next指针方向进入环的第1个节点为环的入口节点。
 */
+ (LinkedNode *)detectCycle:(LinkedNode *)head;

/**
 题目20：输入两个单向链表，请问如何找出它们的第1个重合节点
 */
+ (LinkedNode *)getIntersectionNode:(LinkedNode *)headA headB:(LinkedNode *)headB;

/**
 题目21：给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并且把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的最高位数而尾节点对应整数的个位数.
 解决这个问题的办法是把表示整数的链表反转。反转之后的链表的头节点表示个位数，尾节点表示最高位数。此时从两个链表的头节点开始相加，就相当于从整数的个位数开始相加。
 在做加法时还需要注意的是进位。如果两个整数的个位数相加的和超过10，就会往十位数产生一个进位。在下一步做十位数相加时就要把这个进位考虑进去。
 */
+ (LinkedNode *)addTwoNumbers:(LinkedNode *)head1 head2:(LinkedNode *)head2;

/**
 给定两个表示非负整数的单向链表，请问如何实现这两个整数的相加并且把它们的和仍然用单向链表表示？链表中的每个节点表示整数十进制的一位，并且头节点对应整数的个位数而尾节点对应整数最高位.（不需要反转直接相加）
 */
+ (LinkedNode *)addNodeNumber:(LinkedNode *)head1 head2:(LinkedNode *)head2;

/**
 题目22：给定一个链表，链表中节点的顺序是L0→L1→L2→…→Ln-1→Ln，请问如何重排链表使节点的顺序变成L0→Ln→L1→Ln-1→L2→Ln-2→…？
 */
+ (void)reorderList:(LinkedNode *)head;

/**
 题目23：如何判断一个链表是不是回文？要求解法的时间复杂度是O（n），并且不得使用超过O（1）的辅助空间。如果一个链表是回文，那么链表的节点序列从前往后看和从后往前看是相同的
 */
+ (BOOL)linkIsPalindrome:(LinkedNode *)head;

/**
 题目24：在一个多级双向链表中，节点除了有两个指针分别指向前后两个节点，还有一个指针指向它的子链表，并且子链表也是一个双向链表，它的节点也有指向子链表的指针。请将这样的多级双向链表展平成普通的双向链表，即所有节点都没有子链表。
 1= 2 = 3 = 4
   ｜
   5  =  6 = 7
      ｜
      8 = 9
 结果为1 =2 = 5 = 6 = 8  = 9 = 7 = 3 = 4
 */
+ (LinkChildNode *)flatten:(LinkChildNode *)head;

/**
 题目25：在一个循环链表中节点的值递增排序，请设计一个算法在该循环链表中插入节点，并保证插入节点之后的循环链表仍然是排序的。
 */
+ (LinkedNode *)inset:(LinkedNode *)head value:(int)value;

/**
 题目26：请设计一个算法将二叉树序列化成一个字符串，并能将该字符串反序列化出原来二叉树的算法。
 */
+ (NSString *)serializeForPreorderTraversal:(TreeNode *)node;

/**
 反序列化二叉树
 */
+ (TreeNode *)deserializeForPreorderTraversalString:(NSString *)str;

/**
 题目27：在一棵二叉树中所有节点都在0～9的范围之内，从根节点到叶节点的路径表示一个数字。求二叉树中所有路径表示的数字之和。
         3
       /        \
      9           0
    /       \           \
   5         1           2
 二叉树有3条从根节点到叶节点的路径，它们分别表示数字395、391和302，这3个数字之和是1088。首先考虑如何计算路径表示的数字。顺着指向子节点的指针路径向下遍历二叉树，每到达一个节点，相当于在路径表示的数字末尾添加一位数字。例如，在最开始到达根节点时，它表示数字3。然后到达节点9，此时路径表示数字39（3×10+9=39）。然后向下到达节点5，此时路径表示数字395（39×10+5=395）。
 */
+ (NSInteger)binaryTreeNodesSum:(TreeNode *)root;

/**
 题目28：给定一棵二叉树和一个值sum，求二叉树中节点值之和等于sum的路径的数目。路径的定义为二叉树中顺着指向子节点的指针向下移动所经过的节点，但不一定从根节点开始，也不一定到叶节点结束。例如，在二叉树中有两条路径的节点值之和等于8，其中，第1条路径从节点5开始经过节点2到达节点1，第2条路径从节点2开始到节点6。
        5
     /           \
    2              4
  /      \         /      \
 1        6      3        7
 */
+ (NSInteger)pathSum:(TreeNode *)root sum:(NSInteger)sum;

/**
 题目29：在二叉树中将路径定义为顺着节点之间的连接从任意一个节点开始到达任意一个节点所经过的所有节点。路径中至少包含一个节点，不一定经过二叉树的根节点，也不一定经过叶节点。给定非空的一棵二叉树，请求出二叉树所有路径上节点值之和的最大值。例如，二叉树中，从节点15开始经过节点20到达节点7的路径的节点值之和为42，是节点值之和最大的路径。
     -9
    /      \
   4        20
      /       \
    15          7
   /
 -3
 */
+ (NSInteger)nodeMaxSum:(TreeNode *)node;

/**
 题目30：给定一棵二叉搜索树，请调整节点的指针使每个节点都没有左子节点。调整之后的树看起来像一个链表，但仍然是二叉搜索树。
 */
+ (TreeNode *)increasingBST:(TreeNode *)root;

/**
 题目31：给定一棵二叉搜索树和它的一个节点p，请找出按中序遍历的顺序该节点p的下一个节点。假设二叉搜索树中节点的值都是唯一的。也就是找后继节点
 */
+ (TreeNode *)inorderSuccessor:(TreeNode *)root node:(TreeNode *)p;

/**
 题目32：给定一棵二叉搜索树，请将它的每个节点的值替换成树中大于或等于该节点值的所有节点值之和。假设二叉搜索树中节点的值唯一。
 */
+ (TreeNode *)convertBST:(TreeNode *)root;

/**
 题目33：给定一棵二叉搜索树和一个值k，请判断该二叉搜索树中是否存在值之和等于k的两个节点。假设二叉搜索树中节点的值均唯一。
 */
+ (BOOL)findTarget:(TreeNode *)root k:(NSInteger)k;

/**
 题目34：输入一个排序的整数数组nums和一个目标值t，如果数组nums中包含t，则返回t在数组中的下标；如果数组nums中不包含t，则返回将t按顺序插入数组nums中的下标。假设数组中没有相同的数字。例如，输入数组nums为[1，3，6，8]，如果目标值t为3，则输出1；如果t为5，则返回2。
 */
+ (NSInteger)searchInsert:(NSArray *)arr target:(NSInteger)target;

/**
 题目35：在一个长度大于或等于3的数组中，任意相邻的两个数字都不相等。该数组的前若干数字是递增的，之后的数字是递减的，因此它的值看起来像一座山峰。请找出山峰顶部，即数组中最大值的位置。例如，在数组[1，3，5，4，2]中，最大值是5，输出它在数组中的下标2。
 */
+ (NSInteger)peakIndexInMountainArray:(NSArray *)arr;

/**
 题目36：在一个排序的数组中，除一个数字只出现一次之外，其他数字都出现了两次，请找出这个唯一只出现一次的数字。例如，在数组[1，1，2，2，3，4，4，5，5]中，数字3只出现了一次。
 */
+ (NSInteger)singleNonDuplicate:(NSArray *)arr;

/**
 题目37：输入一个正整数数组w，数组中的每个数字w[i]表示下标i的权重，请实现一个函数pickIndex根据权重比例随机选择一个下标。例如，如果权重数组w为[1，2，3，4]，那么函数pickIndex将有10%的概率选择0、20%的概率选择1、30%的概率选择2、40%的概率选择3。
 */
+ (NSInteger)pickIndex:(NSArray *)arr;

/**
 题目38：输入一个非负整数，请计算它的平方根。正数的平方根有两个，只输出其中的正数平方根。如果平方根不是整数，那么只需要输出它的整数部分。例如，如果输入4则输出2；如果输入18则输出4。
 */
+ (NSInteger)mySqrt:(NSInteger)n;

/**
 题目39：狒狒很喜欢吃香蕉。一天它发现了n堆香蕉，第i堆有piles[i]根香蕉。门卫刚好走开，H小时后才会回来。狒狒吃香蕉喜欢细嚼慢咽，但又想在门卫回来之前吃完所有的香蕉。请问狒狒每小时至少吃多少根香蕉？如果狒狒决定每小时吃k根香蕉，而它在吃的某一堆剩余的香蕉的数目少于k，那么它只会将这一堆的香蕉吃完，下一个小时才会开始吃另一堆的香蕉。
 例如，有4堆香蕉，表示香蕉数目的数组piles为[3，6，7，11]，门卫将于8小时之后回来，那么狒狒每小时吃香蕉的最少数目为4根。如果它每小时吃4根香蕉，那么它用8小时吃完所有香蕉。如果它每小时只吃3根香蕉，则需要10小时，不能在门卫回来之前吃完。
 */
+ (NSInteger)minEatingSpeed:(NSArray *)arr h:(NSInteger)h;

/**
 题目40：请从一个乱序数组中找出第k大的数字。例如，数组[3，1，2，4，5，5，6]中第3大的数字是5。
 */
+ (NSInteger)findKthLargest:(NSArray *)arr k:(NSInteger)k;

/**
 题目41：输入一个链表的头节点，请将该链表排序。例如
 3-5-1-4-2-6
 1-2-3-4-5-6
 */
+ (LinkedNode *)sortList:(LinkedNode *)head;

/**
 题目42：输入k个排序的链表，请将它们合并成一个排序的链表。例如，输入3个排序的链表
 1-4-7
 2-5-8
 3-6-9
 */
+ (LinkedNode *)mergeKLists:(NSArray <LinkedNode *> *)list;


@end

NS_ASSUME_NONNULL_END
